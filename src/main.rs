//! **bb** is a Rust implementation of a very simple language described by Benjamin Pierce
//! in *Types and Programming Languages* (University of Pennsylvania Press, 2002), page 34.
//! There it is called ùîπ, from whence bb.
//!
//!### Grammar
//!
//!```txt
//!value = { "true" | "false" }
//!conditional = { "if" ~ term ~ "then" ~ term ~ "else" ~ term  }
//!term = { value | conditional }
//!```

extern crate pest;
#[macro_use]
extern crate pest_derive;

mod term;

use term::Term;
use pest::Parser;
use rustyline::error::ReadlineError;
use rustyline::Editor;

const HISTORY_FILE: &str = ".ucalc-history";

/// The bb parser, generated by [`pest`].
#[derive(Parser)]
#[grammar = "bb.pest"]
struct BbParser;

fn main() {
    let mut rl = Editor::<()>::new();

    if rl.load_history(HISTORY_FILE).is_err() {
        println!("No previous history.");
    }

    loop {
        let readline = rl.readline(">> ");
        match readline {
            Ok(line) => {
                rl.add_history_entry(line.as_str());

                let output = run_interpreter(&line);
                println!("{}", output);
            },
            Err(ReadlineError::Interrupted) => {
                println!("CTRL-C");
                break
            },
            Err(ReadlineError::Eof) => {
                println!("CTRL-D");
                break
            },
            Err(err) => {
                println!("Error: {:?}", err);
                break
            }
        }
    }

    rl.save_history(HISTORY_FILE).unwrap();
}

fn run_interpreter(src: &str) -> String {
    let p = BbParser::parse(Rule::term, src)
        .expect("err")
        .next()
        .unwrap();
    let t = term::parse_term(p);
    format!("{}", eval(t))
}

#[derive(Clone, Debug)]
pub enum RuntimeError {
    NoRuleApplies,
}

/// Evaluates a term (recursively, in the case of ‚Äúif‚Äù terms).
pub fn eval1(t: Term) -> Result<Term, RuntimeError> {
    let res = match t {
        Term::TmIf(cond, csq, alt) => match *cond {
            Term::TmFalse => *alt,
            Term::TmTrue => *csq,
            _ => Term::TmIf(Box::new(eval1(*cond)?), csq, alt),
        },
        _ => return Err(RuntimeError::NoRuleApplies),
    };
    Ok(res)
}

/// Helper function for evaluation that breaks recursion on normal forms of terms.
///
/// See `is_normal()`.
// TODO Actually understand how this and eval1() work together conceptually.
pub fn eval(t: Term) -> Term {
    let mut r = t;
    while let Ok(tprime) = eval1(r.clone()) {
        r = tprime;
        if r.is_normal() {
            break;
        }
    }
    r
}

#[cfg(test)]
mod test;
