//! **bb** is a Rust implementation of a very simple language described by Benjamin Pierce
//! in *Types and Programming Languages* (University of Pennsylvania Press, 2002), page 34.
//! There it is called ùîπ, from whence bb.
//!
//!### Grammar
//!
//!```txt
//!value = { "true" | "false" }
//!conditional = { "if" ~ term ~ "then" ~ term ~ "else" ~ term  }
//!term = { value | conditional }
//!```

use std::fmt;

extern crate pest;
#[macro_use]
extern crate pest_derive;

use pest::{Parser, iterators::{Pair, Pairs}};

use rustyline::error::ReadlineError;
use rustyline::Editor;

const HISTORY_FILE: &str = ".ucalc-history";

/// The bb parser, generated by [`pest`].
#[derive(Parser)]
#[grammar = "nb.pest"]
struct NbParser;

fn main() {
    let mut rl = Editor::<()>::new();

    if rl.load_history(HISTORY_FILE).is_err() {
        println!("No previous history.");
    }

    loop {
        let readline = rl.readline(">> ");
        match readline {
            Ok(line) => {
                rl.add_history_entry(line.as_str());

                let output = run_interpreter(&line);
                println!("{}", output);
            },
            Err(ReadlineError::Interrupted) => {
                println!("CTRL-C");
                break
            },
            Err(ReadlineError::Eof) => {
                println!("CTRL-D");
                break
            },
            Err(err) => {
                println!("Error: {:?}", err);
                break
            }
        }
    }

    rl.save_history(HISTORY_FILE).unwrap();
}

fn run_interpreter(src: &str) -> String {
    let p = NbParser::parse(Rule::term, src)
        .expect("err")
        .next()
        .unwrap();
    let t = parse_term(p);
    format!("{}", eval(t))
}

/// Takes a [`Pair`] and returns a [`Term`].
pub fn parse_term(p: Pair<'_, Rule>) -> Term {
    let inner_pair = p.into_inner();
    let first_str = inner_pair.as_str().split_whitespace().collect::<Vec<_>>()[0];

    match first_str {
        "if" => parse_if(inner_pair).unwrap(),
        "true" => Term::TmTrue,
        "false" => Term::TmFalse,
        _ => panic!(),
    }
}

/// Parse an ‚Äúif‚Äù term (aka an ‚Äúif statement‚Äù).
///
/// See <https://github.com/lazear/types-and-programming-languages/blob/master/01_arith/src/parser.rs#L54-L61>
pub fn parse_if(p: Pairs<'_, Rule>) -> Option<Term> {
    // "if cond then csq else alt"
    let conditional_str_parts = p.as_str().split_whitespace().collect::<Vec<_>>();

    let cond = Term::from_str(
        conditional_str_parts[1]
    );
    debug_assert_eq!(conditional_str_parts[2], "then");
    let csq = Term::from_str(
        conditional_str_parts[3]
    );
    debug_assert_eq!(conditional_str_parts[4], "else");
    let alt = Term::from_str(
        conditional_str_parts[5]
    );

    Some(Term::TmIf(Box::new(cond), Box::new(csq), Box::new(alt)))
}

/// A term in the grammar.
#[derive(Clone, Debug, PartialEq)]
pub enum Term {
    TmTrue,
    TmFalse,
    TmIf(Box<Term>, Box<Term>, Box<Term>),
}

impl Term {
    // Hack to get boolean normal terms from their string representations.
    pub fn from_str(s: &str) -> Self {
        match s {
            "true" => Term::TmTrue,
            "false" => Term::TmFalse,
            _ => panic!(),
        }
    }

    /// Returns true if the term is in normal (irreducible) form.
    pub fn is_normal(&self) -> bool {
        match self {
            Term::TmTrue | Term::TmFalse => true,
            _ => false,
        }
    }
}

impl fmt::Display for Term {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match &self {
            Term::TmTrue => "true",
            Term::TmFalse => "false",
            _ => panic!("We shouldn't need to print an if.")
        };
        write!(f, "{}", s)
    }
}

#[derive(Clone, Debug)]
pub enum RuntimeError {
    NoRuleApplies,
}

/// Evaluates a term (recursively, in the case of ‚Äúif‚Äù terms).
pub fn eval1(t: Term) -> Result<Term, RuntimeError> {
    let res = match t {
        Term::TmIf(cond, csq, alt) => match *cond {
            Term::TmFalse => *alt,
            Term::TmTrue => *csq,
            _ => Term::TmIf(Box::new(eval1(*cond)?), csq, alt),
        },
        _ => return Err(RuntimeError::NoRuleApplies),
    };
    Ok(res)
}

/// Helper function for evaluation that breaks recursion on normal forms of terms.
///
/// See `is_normal()`.
// TODO Actually understand how this and eval1() work together conceptually.
pub fn eval(t: Term) -> Term {
    let mut r = t;
    while let Ok(tprime) = eval1(r.clone()) {
        r = tprime;
        if r.is_normal() {
            break;
        }
    }
    r
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_true() {
        let src: &str = "true";
        let p = NbParser::parse(Rule::term, &src)
            .expect("err")
            .next()
            .unwrap();

        let term = parse_term(p);
        assert_eq!(term, Term::TmTrue);
    }

    #[test]
    fn test_parse_false() {
        let src: &str = "false";
        let p = NbParser::parse(Rule::term, &src)
            .expect("err")
            .next()
            .unwrap();

        let term = parse_term(p);
        assert_eq!(term, Term::TmFalse);
    }

    #[test]
    fn test_parse_if() {
        let src: &str = "if true then true else false";
        let p = NbParser::parse(Rule::term, &src)
            .expect("err")
            .next()
            .unwrap();

        let term = parse_if(Pairs::single(p));
        let want = Some(Term::TmIf(Box::new(Term::TmTrue), Box::new(Term::TmTrue), Box::new(Term::TmFalse)));
        assert_eq!(term, want);
    }
}
